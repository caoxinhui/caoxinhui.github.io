---
title: 位运算
date: 2020-02-22 13:44:24
tags:
categories: 算法
---

### 不用额外变量交换两个整数的值
```js
a = a ^ b
b = a ^ b
a = a ^ b
```

### 不用比较找到两数中较大的数（32位整数）
```js
function flip(n) {
  return n ^ 1
}
function sign(number) {
  return flip((number >> 1) & 1)
}


function getBigger(a, b) {
  const c = a - b
  const signC = sign(c)
  const flipC = flip(signC)
  return a * signC + b * flipC
}

```

### 不用比较找到两数中较大的数
👇如果a的符号和b的符号不同，(difSignAB=1,sameSignAB=0)
- 如果a为正，b为负(signA=1,signB=0)，返回a
- 如果a为负，b为正(signA=0,signB=1)，返回b
👇如果a的符号和b的符号相同，(difSignAB=0,sameSignAB=1)
- 如果a-b为正，signC=1，返回a
- 如果a-b为负，signC=0，返回b
```js
function flip(n) {
  return n ^ 1
}
function sign(number) {
  return flip((number >> 1) & 1)
}

function getBigger(a, b) {
  const c = a - b
  const signA = sign(a)
  const signB = sign(b)
  const signC = sign(c)
  const difSignAB = signA ^ signB
  const sameSignAB = flip(difSignAB)
  const returnA = difSignAB * signA + sameSignAB * signC
  const returnB = flip(returnA)
  return a * returnA + b * returnB
}
```

### 位运算符实现加减乘除
#### 加
- 在完全不考虑进位的情况下，a^b就是正确结果
- 在只算进位的情况下，进位(a&b)<<1
- 把完全不考虑进位的相加值与只考虑进位的产生值再相加，就是最终结果
```js
function add(a, b) {
  let sum = a
  while (b !== 0) {
    sum = a ^ b
    b = (a & b) << 1
    a = sum
  }
  return sum
}
```

#### 减
实现a-b只要实现a+(-b)即可，得到一个数的相反数，就是这个数的二进制数表达取反加一的结果。
```js
function negNum(n) {
  return add(~n, 1)
}

function minus(a, b) {
  return add(a, negNum(b))
}
```
#### 乘
a * b = a * 2^0 * b0 + a * 2^1 * b1 + …… + a * 2^i * bi + a * 2^31 * b31 
- b最右侧为1时，res = res + a，同时b右移1位，a左移一位
- b最右侧为0时，res不变，同时b右移1位，a左移一位
```js
function multi(a, b) {
  let res = 0
  while (b !== 0) {
    if ((b & 1) !== 0) {
      res = add(res, a)
    }
    a <<= 1
    b >>= 1
  }
  return res
}
```

#### 除

```js
function isNeg(n) {
  return n < 0
}

function div(a, b) {
  let x = isNeg(a) ? negNum(a) : a
  let y = isNeg(b) ? negNum(b) : b
  let res = 0
  for (let i = 31; i > -1; i = minus(i, 1)) {
    if ((x >> i) >= y) {
      res |= (1 << i)
      x = minus(x, y << i)
    }
  }
  return isNeg(a) ^ isNeg(b) ? negNum(res) : res
}
```

```js
function isNeg(n) {
  return n < 0
}

function div(a, b) {
  let x = isNeg(a) ? negNum(a) : a
  let y = isNeg(b) ? negNum(b) : b
  let res = 0
  for (let i = 31; i > -1; i = minus(i, 1)) {
    if ((x >> i) >= y) {
      res |= (1 << i)
      x = minus(x, y << i)
    }
  }
  return isNeg(a) ^ isNeg(b) ? negNum(res) : res
}

function divide(a, b) {
  if (b === 0) {
    throw new Error('divisor is 0')
  }
  if (a === Number.MAX_SAFE_INTEGER && b === Number.MIN_SAFE_INTEGER) {
    return 1
  } else if (b === Number.MIN_SAFE_INTEGER) {
    return 0
  } else if (a === Number.MIN_SAFE_INTEGER) {
    let res = div(add(a, 1), b)
    return add(res, div(minus(a, multi(res, b)), b))
  } else {
    return div(a, b)
  }
}
```

### 二进制表达式有多少1

```js
function count1(n) {
  let res = 0
  while (n !== 0) {
    res += n & 1
    n >>= 1
  }
  return res
}
```
n &= (n - 1) 操作，是抹掉最右边的1

```js
function count2(n) {
  let res = 0
  while (n !== 0) {
    // 抹掉最右边的1
    n &= (n - 1)
    res++
  }
  return res                              
}
```

```js
function count3(n) {
  let res = 0
  while (n !== 0) {
    n -= n & (~n + 1)
    res++
  }
  return res
}

```

### 在其他数都出现偶数次的数组中找到出现奇数次的数
遍历数组，对每个数异或，最后的值就是出现奇数次的那个数。异或满足交换律和结合律。像个相同的数异或之后为0
```js
function oddTimesNum(arr) {
  let res = 0
  for (let i = 0; i < arr.length; i++) {
    res ^= arr[i]
  }
  return res
}

```


### 有两个数出现了奇数次，打印这两个数
```js
function printOddTimesNum(arr) {
  let e0 = 0
  let e0hasOne = 0
  for (let i = 0; i < arr.length; i++) {
    e0 ^= arr[i]
  }
  let rightOne = e0 & (~e0 + 1)
  for (let i = 0; i < arr.length; i++) {
    if ((arr[i] & rightOne) !== 0) {
      e0hasOne ^= arr[i]
    }
  }
  const annother = e0 ^ e0hasOne
  return { annother, e0hasOne }
}
```
### 其他数字都出现k次的数组中找到只出现一次的数
k进制的两个数，在i位上无进位相加的结果就是(c(i)+d(i))%k,那么如果k个相同的k进制数进行无进位相加，相加的结果一定是每一位上都是0的k进制数