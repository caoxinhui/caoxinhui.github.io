---
title: 倒计时
date: 2019-12-28 17:34:28
tags: 项目经历
categories: 项目经历
---

## 最近用两种写发写了倒计时的功能

<!-- more -->


### 第一种，通过requestAnimationFrame实现
我们用 Hooks 来实现倒计时的功能。
找到一篇相同的文章，[点击](https://css-tricks.com/using-requestanimationframe-with-react-hooks/)

在函数式组件中，有三种方式存储变量
- 通过 let 或者 const 定义一个变量，每当组件重新渲染的时候，这些变量都会重新被初始化
- 通过 useState ,在多次重新渲染之后，它的值保持不变。并且，如果通过 setState 改变了它的值，也会引起 重新渲染
- useRef

useRef 最开始使用，是指向 DOM 的，但他的用处并不仅仅如此。他是一个可变的对象，并且在多次渲染后还能保持他的值不变。
useRef 定义的变量 和 useState 定义的变量相似，除了读取和更新他的值通过 .current 属性，除了改变他的值不会触发重新渲染

👇当 Component 组件的父组件不停 render 的时候，Component 组件也会跟着render，但是 variable 的值保持不变。
其中 setTimeout 函数会执行，但是 variable 的值始终保持 5。
 
```jsx
function Component() {
  let variable = 5;

  setTimeout(() => {
    variable = variable + 3;
  }, 100)

  return <div>{variable}</div>
}
```

👇 当使用 useState 时，就算父组件不重新渲染， variable 的值还是会每隔一秒增加 3
因为当页面渲染时，setTimeout 会在一秒后 setVariable，而 setVariable 会触发组件渲染，而组件渲染又会导致 setTimeout 一秒后 setVariable
```jsx
function Component() {
    let [variable,setVariable] = useState(5)
    setTimeout(function () {
        setVariable(variable+3)
    },1000)
    return (
        <div>{variable}</div>
    )
}
```

 👇 当使用 useRef ，组件会返回 5，并且不会触发重新渲染。但是，如果父组件重新渲染，会引起 variable 每次增加 3。
 ⚠️ 注意，第一次渲染后，setTimeout 执行 1 秒后加 3，并不会导致 variable 加 3，因为没有触发重渲染。
```jsx
function Component() {
    let variable = useRef(5)
    setTimeout(function () {
        variable.current += 3
    },1000)
    return (
        <div>{variable.current}</div>
    )
}
```

✅ 在这里，我们需要使用 useRef 的两个地方
- request animation frame ID
- 前一次的 timestamp



#### useEffect
useEffect 方法只执行一次，因此，给 useEffect 的第二个参数传递一个空数组。
但是，传递空数组有一个副作用，在动画期间，我们不能获取到正确的 state 信息。
第二个参数应该是一系列改变的值，而因为这些值的改变，组件需要作出相应的改变。
如例子所示，animation 中的 state 值，始终是初始值，不会因为 setState 而导致 animate 中的值发生变化。
```jsx
function App() {
  const [state, setState] = React.useState(0)
  const requestRef = React.useRef()
  const animate = time => {
    // The 'state' will always be the initial value here
    requestRef.current = requestAnimationFrame(animate);
  }
  React.useEffect(() => {
    requestRef.current = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(requestRef.current);
  }, []); // Make sure the effect runs only once
  return <div>{state}</div>;
}
```
那在 useEffect 中怎么获取最新状态呢？
🙌通过 `setState(prevState => prevState + delta)`

实现的功能是：从 1 数到 100， 之后回到 1 重新开始计数
看看代码

```js
const Counter = () => {
    const [count, setCount] = React.useState(0)
    const requestRef = React.useRef();
    const previousTimeRef = React.useRef();
    const animate = time => {
        if (previousTimeRef.current != undefined) {
            const deltaTime = time - previousTimeRef.current;
            setCount(prevCount => (prevCount + deltaTime * 0.01) % 100);
        }
        previousTimeRef.current = time;
        requestRef.current = requestAnimationFrame(animate);
    }
    React.useEffect(() => {
        requestRef.current = requestAnimationFrame(animate);
        return () => cancelAnimationFrame(requestRef.current);
    }, []); 

    return <div>{Math.round(count)}</div>
}
```
👏 将主要逻辑迁移到 自定义Hook。
- 简化我们的组件，隐藏变量，不对组件影响
- 自定义组件可复用

作为公约，自定义组件应该以 use 开头，并且 hooks 的规则适用。


```jsx
const useAnimationFrame = callback => {
    const requestRef = React.useRef();
    const previousTimeRef = React.useRef();
    const animate = time => {
        if (previousTimeRef.current != undefined) {
            const deltaTime = time - previousTimeRef.current;
            callback(deltaTime)
        }
        previousTimeRef.current = time;
        requestRef.current = requestAnimationFrame(animate);
    }

    React.useEffect(() => {
        requestRef.current = requestAnimationFrame(animate);
        return () => cancelAnimationFrame(requestRef.current);
    }, []);
}

const Counter = () => {
    const [count, setCount] = React.useState(0)
    useAnimationFrame(deltaTime => {
        setCount(prevCount => (prevCount + deltaTime * 0.01) % 100)
    })
    return <div>{Math.round(count)}</div>
}
```



通过 `document.addEventListener("visibilitychange",this.diffTime,false)` 触发可视监听事件。
但是，通过浏览器打开的页面，比如微信浏览器， `safari` 浏览器，其他手机自带浏览器等等，是在当前页面新开的，所以不会触发 `visibilitychange` 事件，相当于一直在当前页面，从来没有离开视口。而且浏览器会对打开的也没进行缓存，页面回退不会重新从 `componentwillcreate` 生命周期开始，只会从 `componentdidmount` 开始，也就是服务端生成的 `html` 不会重新请求，只会对客户端的操作重新开始执行。
 解决方法是
 静态 `html` 中添加

``` html
<input type="hidden" id="refreshed" value="no" />
```

`componentDidMount` 中添加
 

``` js
 disableHTMLCache = () => {
     if (typeof window !== "undefined") {
         window.onload = function() {
             let e = document.getElementById("refreshed");
             if (e.value == "no") {
                 e.value = "yes";
             } else {
                 e.value = "no";
                 location.reload();
             }
         };
     }
 };
```

[浏览器特性支持](https://developers.google.com/web/updates/2019/02/back-forward-cache)

#### 第二种，通过setInterval实现

  + `JS` 主线程执行时有一个栈存储运行时的函数相关变量, 遇到函数时会先入栈执行完后再出栈。当遇到 `setTimeout`  `setInterval`  `requestAnimationFrame` 以及 `I/O` 操作时，这些函数会立刻返回一个值（如 `setInterval` 返回一个 `intervalID` ）保证主线程继续执行，而异步操作则由浏览器的其它线程维护。当异步操作完成时，浏览器会将其回调函数插入主线程的任务队列中，当主线程执行完当前栈的逻辑后，才会依次执行任务队列中的任务。 

  + 但是在每个任务之间，还有一个微任务队列的存在。在当前任务执行完后，将先执行微任务队列中的所有任务，例如 `Promise`  `process.nextTick` 等操作。也就是说当 `setInterval(fn, 1000)` 等待 `1` 秒钟后， `fn` 函数会被插入任务队列中，但并不一定会立刻执行，还需要等待当前任务以及微任务队列中的所有任务执行完。长此以往，使用 `setInterval` 的计时器超时将越来越严重。

```js
console.log('console.log()')
setTimeout(function() {
    console.log('setTimeOut')
})
Promise.resolve().then(function() {
    console.log('promise1')
}).then(function() {
    console.log('promise2')
})
console.log('script end')
```

```js
 let [milliSecs, setmilliSecs] = useState(remainingTime);

 const startCountDown = async () => {
     milliSecs -= 1000;
     setmilliSecs(milliSecs);
     if (milliSecs <= 0) {
         clearInterval(timer);
         await updateInitialData();
     }
 };

 useEffect(() => {
     timer = setInterval(startCountDown, 1000);
     return () => {
         clearInterval(timer);
     };
 }, []);
```
