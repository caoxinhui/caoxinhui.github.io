---
title: 最长递增子序列
date: 2020-02-19 14:25:26
tags:
categories: 算法
---

生成长度为 N 的数组dp，dp[i]表示在arr[i] 这个数结尾的情况下，arr[0…i] 中的最长递归子序列

如果最长递归子序列以arr[i]结尾，那么在arr[0…i]中所有比arr[i]小的数，都可以作为倒数第二个数。在这么多倒数第二个数的选择中，以哪个数结尾的最大递增子序列更大，就选哪个数作为倒数第二个数。

<!-- more -->

### 方法一

``` js
const arr = [2, 1, 5, 3, 6, 4, 8, 9, 7]

function increNum(arr) {
    const len = arr.length
    let dp = Array(len)
    for (let i = 0; i < len; i++) {
        dp[i] = 1
        for (let j = 1; j < i; j++) {
            if (arr[i] > arr[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
    }
    return dp
}
```

接下来根据dp，求出dp的最长递增子序列

1. 找到 dp 中的最大值的位置 index
2. 从 index 向左遍历，如果既有 arr[index] > arr[i], 又有 dp[i] + 1 = dp[index], i 即为所求

``` js
function generateLIS(arr, dp) {
    // 最长递增子序列长度
    let len = 0
    // 最大值所在位置
    let index = 0
    for (let i = 0; i < dp.length; i++) {
        if (dp[i] > len) {
            index = i
            len = dp[i]
        }
    }
    let lis = Array(len)
    lis[--len] = arr[index]
    for (let i = index; i >= 0; i--) {
        if (arr[i] < arr[index] && dp[i] + 1 === dp[index]) {
            lis[--len] = arr[i]
            index = i
        }
    }
    return lis
}

function list(arr) {
    if (!arr || arr.length === 0) {
        return null
    }
    const dp = increNum(arr)
    return generateLIS(arr, dp)
}
```

计算dp数组的时间复杂度为O(N^2)，generateLIS时间复杂度为O(N)，所以整个过程的时间复杂度为O(N^2)

### 方法二
😓 **未完成**
通过二分查找来进行优化。时间复杂度O(NlogN)

1. 先生成长度为 N 的数组 ends，初始时 ends[0] = arr[0]，其他位置上的值为 0
2. 生成整型变量right，初始时right = 0
3. ends[0…right] 为有效区，ends[right+1…N-1] 为无效区
4. 对有效区上的位置b，如果有 ends[b] == c，表示到目前为止，在所有长度为b+1的递增序列中，最小的结尾数为c

```js

function increNum(arr) {
  const len = arr.length
  let dp = Array(len)
  let ends = Array(len)
  ends[0] = arr[0]
  dp[0] = 1
  let right = 0
  let l = 0
  let r = 0
  let m = 0
  for (let i = 1; i < len; i++) {
    l = 0;
    r = right
    while (l <= r) {
      m = Math.floor((l + r) / 2)
      if (arr[i] > ends[m]) {
        l = m + l
      } else {
        l = m - l
      }
    }
    right = Math.max(right, l)
    ends[l] = arr[i]
    dp[i] = l + 1
  }
  return dp
}
```