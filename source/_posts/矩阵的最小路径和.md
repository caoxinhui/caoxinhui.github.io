---
title: 矩阵的最小路径和
date: 2020-02-19 10:35:38
tags: 读书笔记
categories: 算法
---
### 方法一
思路：dp[i][j]的值表示从左上角的位置走到(i, j)位置的最小路径和
<!-- more -->
👇js 定义二维数组

``` js
function create2DArray(m, n) {
    let arr = Array(m)
    for (let i = 0; i < m; i++) {
        arr[i] = Array(n)
    }
    return arr
}
// Array(m)中每一个元素都是 empty ,必须要加上fill,才能正常 map
function create2DArray(m, n) {
    const twoDArray = Array(m).fill([]).map(_ => Array(n))
    return twoDArray
}
```
👇动态规划解法：以空间换时间
``` js
const m = [
    [1, 3, 5, 9],
    [8, 1, 3, 4],
    [5, 0, 6, 1],
    [8, 8, 4, 0]
]

function minPathSum(m) {
    if (!m || m.length === 0 || !m[0] || m[0].length === 0) return 0
    const row = m.length
    const col = m[0].length
    // js 定义二维数组
    let dp = create2DArray(row, col)
    dp[0][0] = m[0][0]
    for (let i = 1; i < row; i++) {
        dp[i][0] = dp[i - 1][0] + m[i][0]
    }
    for (let j = 1; j < col; j++) {
        dp[0][j] = dp[0][j - 1] + m[0][j]
    }
    for (let i = 1; i < row; i++) {
        for (let j = 1; j < col; j++) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + m[i][j]
        }
    }
    return dp[row - 1][col - 1]
}
```


矩阵中一共有 M*N 个位置，每个位置都计算一次从(0,0)位置到达自己的最小路径和，时间复杂度为O(M*N)，空间复杂度为O(M*N)

### 方法二

压缩空间 O(M*N) -> O(min{M,N})

```js
function minPathSum(m) {
    if (!m || m.length === 0 || !m[0] || m[0].length === 0) return 0
    const row = m.length
    const col = m[0].length
    const more = Math.max(row, col)
    const less = Math.min(row, col)
    const rowMore = more === row
    let arr = Array(less)
    arr[0] = m[0][0]
    for (let i = 1; i < less; i++) {
      arr[i] = arr[i - 1] + (rowMore ? m[0][i] : m[i][0])
    }
    for (let i = 1; i < more; i++) {
      arr[0] = arr[0] + rowMore ? m[i][0] : m[0][i]
      for (let j = 1; j < less; j++) {
        arr[j] = Math.min(arr[j - 1], arr[j]) + (rowMore ? m[i][j] : m[j][i])
      }
    }
    return arr[less - 1]
  }
```

