---
title: 编写有弹性的组件
date: 2020-01-10 11:39:47
tags: 读书笔记
categories: coding
---

[原文链接](https://overreacted.io/zh-hans/writing-resilient-components/)

<!-- more -->

### 不要阻止数据流

当别人使用你的组件的时候，他们期望的是，不论他们传递什么props，组件将反应这些变化

``` js
function Button({
    color,
    children
}) {
    return ( <
        button className = {
            'Button-' + color
        } > {
            children
        } <
        /button>
    )
}
```

然而，一个常见的错误是，把props复制给state

``` js
class Button extends React.Component {
    state = {
        color: this.props.color
    }
    render() {
        const {
            color
        } = this.state
        return ( <
            button className = {
                'Button-' + color
            } > {
                this.props.children
            } <
            /button>
        )
    }
}
```

但是，通过将prop复制到state，你忽略了对他所有的更新。

计算值是另一个大家可能会将 props 复制到 state 的场景。举例来说，想象一下 按钮文字 的颜色是根据 color 属性通过昂贵计算得来：

``` js
class Button extends React.Component {
    state = {
        color: slowlyCalculateTextColor(this.props.color)
    }
    render() {
        return ( <
            button className = {
                'Button-' + this.props.color +
                'Button-text-' + this.state.textColor
            } > {
                this.props.children
            } <
            /button>
        )
    }
}
```

最简单的修复是把 textColor 的计算放到 render 方法中，然后把组件改为 PureComponent：

``` js
class Button extends React.PureComponent {
    render() {
        const textColor = slowlyCaculateTextColor(this.props.color)
        return ( <
            button className = {
                'Button-' + this.props.color +
                'Button-text-' + textColor
            } > {
                this.props.children
            } <
            /button>
        )
    }
}
```

问题解决了！现在当 props 改变时重新计算 textColor，但是在属性不变时，能避免重复进行昂贵计算。

然而，也许我们还能再优化一下。如果 children 改变了呢？很遗憾 textColor 在这种情况下会重复计算。我们第二次尝试可能是通过在 componentDidUpdate 中调用计算。

``` js
class Button extends React.Component {
    state = {
        textColor: slowlyCaculateTextColor(this.props.color)
    }
    componentDidUpdate(prevProps) {
        if (prevProps.color !== this.props.color) {
            this.setState({
                textColor: slowlyCaculateTextColor(this.props.color)
            })
        }
    }
    render() {
        return ( <
            button className = {
                'Button-' + this.props.color +
                ' Button-text- ' + this.state.textColor
            } > {
                this.props.children
            } <
            /button>
        )
    }
}
```

``` js
function Button({
    color,
    value
}) {
    const textColor = useMemo(() => slowlyCaculateTextColor(color), [color])
    return ( <
        button className = {
            'Button-' + color + 'Button-text-' + textColor
        } > {
            children
        } <
        /button>
    )
}
```

#### 不要在 Side Effects 里阻断数据流

解决方法，使用useEffect

### 时刻准备渲染

React 组件使你写渲染代码的时候不用考虑太多关于时间。你考虑在任意时间UI应该怎么展示，React来实现他。利用好这种模式。

不要尝试在组件行为中，假设不必要的的时序信息。**你的组件应该在任何时候都能重新渲染**

如何违背这个原则呢？——你可以使用 `componentWillReceiveProps` 

``` js
class TextInput extends React.Component {
    state = {
        value: ""
    }
    componentWillReceiveProps(nextProps) {
        this.setState({
            value: nextProps.value
        })
    }
    handleChange = e => {
        this.setState({
            value: e.target.value
        })
    }
    render() {
        return ( <
            input value = {
                this.state.value
            }
            onChange = {
                this.handleChange
            }
            />
        )
    }
}
```

在这个例子中，我们把value值私有，但是我们依然从props接收value值，当接收到新props，我们重置状态中的value
**这种模式的问题是，他完全依赖于偶然的时间**
也许今天父组件极少地更新，我们的TextInput组件只有在重要事件发生时才会接收props，例如保存表单
但是明天，你可能会给父组件加一些动画，如果父组件经常re-render，它将污染子组件的状态。[你可能不需要派生state](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html)

**我们该怎么修复呢？**
我们需要停止将 “接收props” 和 “rendering”看成不同的东西。由父组件引起的re-render 不应与 本身状态 改变引起的 re-render。**组件应该是有弹性的，能适应更少或者更频繁的渲染，否则他们会与特定父组件存在过多耦合**

从props派生state的几种解决方案，

* 1、通常你该使用一个完全受控制的组件

``` js
function TextInput({
    value,
    onChange
}) {
    return ( <
        input value = {
            value
        }
        onChange = {
            onChange
        }
        />
    )
}
```

* 2、或者使用一个不受控制的组件，加上key来重置他

``` js
function TextInput() {
    const [value, setValue] = useState('')
    return ( <
        input value = {
            value
        }
        onChange = {
            e => setValue(e.target.value)
        }
        />
    )
}
// 通过改变key重置组件
<
TextInput key = {
    formId
}
/>
```

本节的内容是，组件不应该因为他本身或者他父组件的重新渲染，而坏掉。

要对你的组件进行压力测试，可以将下面代码加入到父组件：

``` js
componentDidMount() {
    setInterval(() => this.forceUpdate(), 100)
}
```

你看你会想：我在props改变时重置state，再用pureComponent避免不必要的重渲染
这段代码应该能工作，对吧？

``` js
class TextInput extends React.PureComponent {
    state = {
        value: ""
    }
    componentWillReceiveProps(nextProps) {
        this.setState({
            value: nextProps.value
        })
    }
    handleChange = (e) => {
        this.setState({
            value: e.target.value
        })
    }
    render() {
        return ( <
            input value = {
                this.state.value
            }
            onChange = {
                this.handleChange
            }
            />
        )
    }
}
```

乍一看，他看起来解决了 当 父组件 重新渲染的时候，子组件状态受污染的问题。但是，当props一致，我们就跳过了更新。componentWillReceiveProps也不会被执行。
然而，**当实际props改变的时候，组件仍然没有弹性**。例如，我们加另一经常改变的props：style，我们还是会丢失内部状态。

``` js
< TextInput
style = {
    {
        opacity: someValueFromState
    }
}
value = {
    value
}
/>
```

