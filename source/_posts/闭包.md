---
title: 闭包
date: 2020-02-27 10:03:49
tags:
categories: 基础
---

### 你不知道的JS
> 闭包晦涩难懂

函数记住并访问其所在的词法作用域，叫做闭包现象，而此时函数对作用域的引用叫做闭包。



bar 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的
词法作用域
```js
function foo() {
    let a = 2
    function bar(){
        console.log(a)
    }
    return bar
}

let baz = foo()
baz()   //调用处
```

无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到 闭包。

```js
function foo() {
    let a = 2
    function baz(){
        console.log(a)
    }
    bar(baz)
}
function bar(fn) {
    fn()  //调用处
}
```


无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包。
```js
let fn
function foo() {
    let a = 2
    function baz(){
        console.log(a)
    }
    fn = baz
}
function bar() {
    fn()
}
foo()
bar()
```


在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包!
❓❓❓ 这个该怎么理解呢




```js
function wait(message) {
    setTimeout(function timer() {
        console.log(message)
    },1000)
}
wait("hello world")
console.log(timer)
```

IIFE 会通过声明并立即执行一个函数来创建作用域

思考以下几种情况

```js
for(var i=1;i<5;i++){
    setTimeout(function () {
        console.log(i)
    },i*1000)
}
// 5 5 5 5
```


```js
for(var i=1;i<5;i++){
    (function(i){
        setTimeout(function () {
            console.log(i)
        },i*1000)
    })(i)
// 1 2 3 4
}
```


```js
for(var i=1;i<5;i++){
     // let j = i 用来在每个迭代中储存 i 的值
     (function(){
         let j = i
         setTimeout(function () {
             console.log(j)
         },j*1000)
     })()
}
// 1 2 3 4
```

```js
for(var i=1;i<5;i++){
    let j = i
    setTimeout(function () {
        console.log(j)
    },j*1000)
}
// 1 2 3 4
```

### 模块模式

foo 可以被调用多次，每次都会创建一个新的模块实例
```js
function foo() {
    var something = "cool"
    var annother = [1,2,3]
    function dosomething (){
        console.log(something)
    }
    function doAnnother() {
        console.log(annother.join(' ! '))
    }
    return {
        dosomething,
        doAnnother
    }
}

var CoolModule = foo()
CoolModule.dosomething()
CoolModule.doAnnother()
```

略微改造后是单例模式
```js
const foo = (function CoolModule() {
    var something = "cool"
    var annother = [1,2,3]
    function dosomething (){
        console.log(something)
    }
    function doAnnother() {
        console.log(annother.join(' ! '))
    }
    return {
        dosomething,
        doAnnother
    }
})()

foo.dosomething()
foo.doAnnother()
```


### JavaScript 设计模式与开发实践

每次都是弹出 nodes.length， 原因是 onClick 事件是异步触发的，for 循环早已经结束。
```js
var nodes = document.getElementsByTagName( 'div' );
for ( var i = 0, len = nodes.length; i < len; i++ ){
    nodes[ i ].onclick = function(){
    alert ( i );
    }
};
```
解决方法是，利用闭包，将每次循环的 i 值都封闭起来
```js
for ( var i = 0, len = nodes.length; i < len; i++ ){
    (function (i) {
        nodes[ i ].onclick = function() {
            alert(i);
        }
    })(i)
};
```

#### 闭包应用场景
- img 上报数据
```js
var report = function (src) {
    var img = new Image()
    img.src=src
}
report("")
```
但是 report 不是每次都成功发起 HTTP 请求。
原因是，img 在 report 是局部变量，当 report 函数调用结束后， img 就会被回收。而此时或许还没来得及发起 HTTP 请求

解决，把 img 用闭包包裹起来

```js
var report = (function () {
    var imgs = []
    return function (src) {
        var img = new Image()
        imgs.push(src)
        img.src=src
    }
})()
report("")
```

#### 闭包与内存管理
使用闭包的同时容易形成循环应用。
在基于引用计数的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都没办法被回收。

循环引用实例

```js 

function assignHandler() {
     var element = document.querySelector("#element")
     element.onclick=function () {
      console.log(element.id)
     }
 }
```


#### 所有回调函数都是闭包的理解

>回调函数是一个函数，将会在另一个函数完成执行后立即执行。回调函数是一个作为参数传给另一个 JavaScript 函数的函数。这个回调函数会在传给的函数内部执行

无论通过何种手段将内部函数传递到其所在的词法作用域外，它都会持有对原始定义作用域的引用。也就是说，无论在什么地方执行这个函数，都会使用闭包。
```js
var fn;
function foo(){

    var a = 2;

    function baz() {
        console.log( a );
    }
    fn = baz; //将baz 分配给全局变量
}

function bar(){
    fn();
}
foo();
bar(); //2
```
