---
title: 面试题汇总
date: 2020-02-29 12:21:31
tags:
categories: 面试
---


### 遍历一个 DOM 树

```js
function traversal(node) {
    if(node && node.nodeType===1){
        console.log(node.tagName)
    }
    const childs = node.childNodes
    for(let i = 0;i<childs.length;i++){
        traversal(childs[i])
    }
}
```
<!-- more -->

### new 操作的实现
- 创建一个空对象，并把 this 指向空对象
- 继承了函数的原型
- 属性和方法被加入到 this 引用的对象中
- 新创建的对象由 this 引用，最后隐式返回 this

```js
function new(Function) {
    let obj = {
    }
    obj.__proto__ = Function.prototype
    let res = Function.call(obj)
    if(typeof(res) ==="function" || typeof(res) ==="object"){
        return res
    }
    return obj
}
```

### __proto__ 和 prototype 的区别

- 对象有属性__proto__,指向该对象的构造函数的原型对象

### 实现 call 函数
[参考文章](https://github.com/mqyqingfeng/Blog/issues/11)

call 使用方法
```js
function foo() {
    console.log(this.name)
}
let obj = {
    name: "obj name"
}
foo.call2(obj)
```
call 作用
- 将 this 指向了 obj
- 执行了 foo 函数

变形

```js
let obj = {
    name:"obj name",
    foo:function () {
        console.log(this.name)
    }
}
```

- 将函数变成对象的属性
- 执行函数
- 删除函数
```js

obj.fn = foo
obj.fn()
delete obj.fn
```
实现，成功✅
```js
Function.prototype.call2 = function (context) {
    context.fn = this
    context.fn()
    delete context.fn
}
function foo() {
    console.log(this.name)
}
let obj = {
    name: "obj name"
}
foo.call2(obj)
```

如果传入参数
```js

function foo(hello,age) {
    console.log(this.name)
    console.log(hello,age)
}
let obj = {
    name: "obj name"
}
foo.call(obj,"hello",14)
```


实现方式


```js
Function.prototype.call2 = function (context) {
    context.fn = this
    let args = []
    for(let i =1;i<arguments.length;i++){
        args.push("arguments[" + i + "]")
    }
    // 执行后 args为 ["arguments[1]", "arguments[2]"]
    eval('context.fn(' + args + ')')
    delete context.fn
}
function foo(hello,age) {
    console.log(this.name)
    console.log(hello,age)
}
let obj = {
    name: "obj name"
}
foo.call2(obj,"hello",14)
```

最后，需要注意
- this 参数可以传 null，当为 null 的时候，视为指向 window 对象
```js
function foo() {
    console.log(this.name)
}
let name = "hello"

foo.call2(null) // hello
```

- 函数可以有返回值
```js
function foo(name,age) {
    return {
        value:this.value,
        name:name,
        age:age
    }
}

const bar = {
    value:1
}
foo.call(bar)
```

```js

Function.prototype.call2 = function (context) {
    context = context || window
    context.fn = this
    let args = []
    for(let i =1;i<arguments.length;i++){
        args.push("arguments[" + i + "]")
    }
    // 执行后 args为 ["arguments[1]", "arguments[2]", "arguments[3]"]
    const result = eval('context.fn(' + args + ')')
    delete context.fn
    return result
}
function foo(name,age) {
    return {
        value:this.value,
        name:name,
        age:age
    }
}

const bar = {
    value:1
}
console.log(foo.call2(bar))
```


### 实现 apply 函数
与 call 实现方法类似。只不过 argument 参数可以直接通过数组拿，而不用自己生成
```js
Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            args.push('arr[' + i + ']');
        }
        result = eval('context.fn(' + args + ')')
    }

    delete context.fn
    return result;
}
```


### 实现 bind 函数
[参考文章](https://github.com/mqyqingfeng/Blog/issues/12)
- 返回函数
- 可以传入参数
```js
const foo={
    value:1
}
function bar() {
    console.log(this.value)
}

const bindFoo = bar.bind(foo)
bindFoo()
```

实现
```js
function bind2(context) {
    const self = this
    return function () {
        return self.apply(context)
    }
}
```

同时，bind 可以实现柯里化

```js
var foo = {
    value: 1
};

function bar(name, age) {
    console.log(this.value);
    console.log(name);
    console.log(age);

}

var bindFoo = bar.bind(foo, 'daisy');
bindFoo('18');
```

实现
```js
function bind2(context) {
    const self = this
    // 获取bind2函数从第二个参数到最后一个参数
    const args = Array.prototype.slice.call(arguments,1)
    return function () {
        // 这个时候的arguments是指bind返回的函数传入的参数
        const bindArgs = Array.prototype.slice.call(arguments)
        return self.apply(context,args.concat(bindArgs))
    }
}
```

```js
Function.prototype.bind2 = function (context) {

    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
```

### HTTPS 原理


### 劫持 HTTP 请求



### 实现 Promise
[参考文章](https://github.com/xieranmaya/blog/issues/3)
### 实现项目按需加载，例如引入的 antd 只加载 button 组件