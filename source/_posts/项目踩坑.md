---
title: 项目踩坑
date: 2020-02-17 11:46:15
tags: 项目经历
---

最近发现，项目重构的过程中，很容易出bug
- 项目重构相较于项目 init ，不会那么谨慎。造成漏洞
- 测试资源也没有合理分配，导致项目重构了，却没有经过测试。
<!-- more -->
主要逻辑比较重的部分在于：优惠券 和 倒计时

- DOM ref 什么时候会变化，感觉用useEffect监听 ref 的变化，并作出相应监听动作没有必要，因为dom ref 很少需要改变的。


### 弹出蒙层后，页面禁止滚动

👇将页面固定
```js
const bodyEl = document.querySelector("body");
bodyEl.style.position = "fixed";
```

🤔但是有一个问题啊，以上方法将 body 位置固定，页面会自动划到最顶上。
👉所以先记录下当前页面的滚动距离，在 body 样式设置为 fixed 之后，修改 body 的 top 值。

```js
  const bodyEl = document.querySelector("body");
  bodyEl.style.position = "fixe
  bodyEl.style.width = "100%";
  bodyEl.style.top = -top + "px";
```

该方法，能使蒙层里面的内容禁止滚动，而不影响蒙层外面的可滚动区域

当需要关闭蒙层时，把一切复原，同时，还有滚动到原先的位置

```js
  const bodyEl = document.querySelector("body");
  const top = -bodyEl.style.top.split("px")[0];
  bodyEl.style.position = "";
  bodyEl.style.top = "";
  window.scrollTo(0, top);
```

componentWillCreate 里面请求数据，请求超时。经过了怎样的过程。为什么页面过一段时间后是白屏。


### Provisional headers are shown


### Promise 模拟异步请求

```js
  async function getData1 () {
    return new Promise(function (resolve, reject) {
      setTimeout(() => {
        resolve([])
      }, 1000)
    })
  }
```

通过使用 promise 模拟接口异常，超时，可以发现，如果将 getData1 操作放在服务端进行（componentWillCreate），那么，页面 loading 的过程需要 10s，在这 10s 的过程中，页面始终是 loading状态，页面白屏，要等 10s 等待结束，才会出现首屏。

而如果放在 componentDidFirstMount 中执行，首屏内容快速加载。但是要等到 10s 之后，才会请求其他接口。

🤔遇到一个问题，如果将请求 getData1 的请求放在 componentDidFirstMount 中，立即执行，组件中Visibility Change 事件会等 getData1 函数完全执行完，才会执行。
但是当，将 getData1 请求放在 componentDidFirstMount 的最后一步。虽然 getData1 也会优先执行，但是在 getData1 结果返回之前，Visibility Change 事件也触发了。

在 componentDidFirstMount 之后， getData1 和 Visibility Change实际上是并列执行的，互不影响。


### `const [active, setActive] = useState(startToLoad)`，当 startToLoad 变化的时候，active 是否会变化

否，startToLoad 只是给 active 提供了一个初始值，赋值结束后，控制权交给 setActive


### 注意点

当多个模板有可能同时更新一个变量时 (List)，并且更新之前可能还有异步操作，在更新 List 之前，一定要拿到最新的 List 信息，而不能通过传递。因为从异步操作之前拿到的 List 不是最新的。